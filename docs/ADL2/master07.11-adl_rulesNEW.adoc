== Rules Section

The `rules` section in an ADL archetype contains _statements_ which relate to the entire archetype, and can be used to express rules that are not possible within the block structure of the `definition` section. Any constraint that references more than one property is in this category, including constraints containing mathematical or logical formulae.

Archetype rules are expressed in a subset of the statement types from the {openehr_bmm}[Basic Meta-Model (BMM)^], specifically, assertions and assignments. These both contain expressions using operators, defined by the {openehr_expression_language}[openEHR Expression Language (EL)^]. An example is the assertion `check map_bp_value = diastolic_bp_value + 0.33 * (systolic_bp_value - diastolic_bp_value)` in which each of the symbols `map_bp_value` ('map' = mean arterial pressure in medicine), `diastolic_bp_value` etc refer to values found within a data instance created according to the archetype containing the assertion.

Archetype rules are defined at design time and consist of expressions whose symbols are mapped to archetype paths. They have data-instance semantics, and are evaluated at run time against data created according to the archetype supplying the values, i.e. the rules do not literally apply to elements of the archetype, but to data instances generated by these elements. Implementing evaluation requires a way of defining the mapping from archetype path to instance-level symbol in a rule, which is achieved by _symbol bindings_, described below.

Since multiple data instances may conform to a single archetype structure or sub-structure, an important consequence of the symbol/path mapping is that a rule that applies to a single archetype constraint structure may be executed multiple times, on multiple conforming instance structures. The rules for determining runtime data binding resolution bindings stated in the archetype are described below.

=== Symbol Specification

The symbols used in rule expressions are defined in two sub-sections under a dedicated archetype `symbols` section: `symbol_definitions` (optional) and `symbol_bindings` (mandatory). The definitions are of the same form as the archetype term definitions and serve the same purpose, i.e. to provide multi-lingual natural language definitions that may be used in tool user interfaces. In each term, a `symbol` attribute may be used to define a translation of the symbol itseld, which may be used They are optional since they are not needed to perform either path mapping or runtime execution.

.at-coded ADL2 syntax
[source, adl]
----
symbols
    symbol_definitions = <
        ["en"] = <
           ["apgar_respiratory_value"] = <
               text = <"Apgar score respiratory value">
           >
        >
        ["nl"] = <
           ["apgar_respiratory_value"] = <
               text = <"Apgar score ademhalingswaarde">
               symbol = <"apgar_score_ademhalingswaarde">
           >
        >
    >
    symbol_bindings = <
        ["apgar_respiratory_value"] = <"/data[at0002]/events/data[at0001]/items[at0009]/value[at9001]/value">
    >
----

.id-coded ADL2 syntax
[source, adl]
----
symbols
    symbol_definitions = <
        ["en"] = <
           ["apgar_respiratory_value"] = <
               text = <"Apgar score respiratory value">
           >
        >
        ["nl"] = <
           ["apgar_respiratory_value"] = <
               text = <"Apgar score ademhalingswaarde">
               symbol = <"apgar_score_ademhalingswaarde">
           >
        >
    >
    symbol_bindings = <
        ["apgar_respiratory_value"] = <"/data[id3]/events/data[id2]/items[id10]/value[id43]/value">
    >
----

=== Rule Categories

The following sub-sections describe common categories of rule used in archetypes. They also provide a basis for explanation of the rule semantics, including binding resolution.

==== Arithmetic Relationship

A common need is to assert an arithmetic relationship among various values located at different paths within an archetype. The following example specifies the summation of an Apgar score total from its parts, each defined as distinct nodes within the archetype. The `apgar_total_value`, `apgar_heartrate_value` etc are EL variables bound to the relevant paths within the main archetype definition.

.at-coded ADL2 syntax
[source, adl]
----
archetype (adl_version=2.x.x; rm_release=1.0.3; generated; uid=f27fac48-3acb-4061-9619-c783fd8346ab)
  openEHR-EHR-OBSERVATION.apgar.v1.0.1

description
  lifecycle_state = <"unmanaged">
  original_author = <...>
  details = <...>
    
definition
  OBSERVATION[at0000] ∈ {  -- Apgar score
    data ∈ {
      HISTORY[at0002] ∈ {
        events ∈ {
          POINT_EVENT[at0003] occurrences ∈ {0..1} ∈ { -- 2 minutes
            offset ∈ {
              DV_DURATION[at9000] ∈ {
                value ∈ {PT1M}
              }
            }
            data ∈ {
              ITEM_LIST[at0001] ∈ {
                items ∈ {
                  ELEMENT[at0009] occurrences ∈ {0..1} ∈ {
                    value ∈ {
                      DV_ORDINAL[at9001] ∈ {
                        [value, symbol] ∈ { -- apgar_respiratory_value
                          [{0}, {[at0010]}],
                          [{1}, {[at0011]}],
                          [{2}, {[at0012]}]
                        }
                      }
                    }
                  }
                  ELEMENT[at0005] occurrences ∈ {0..1} ∈ {...} -- apgar_heartrate_value
                  ELEMENT[at0013] occurrences ∈ {0..1} ∈ {...} -- apgar_muscle_tone_value
                  ELEMENT[at0017] occurrences ∈ {0..1} ∈ {...} -- apgar_reflex_value
                  ELEMENT[at0021] occurrences ∈ {0..1} ∈ {...} -- apgar_skin_colour_value
                  ELEMENT[at0025] occurrences ∈ {0..1} ∈ {
                    value ∈ {
                      DV_COUNT[at9002] ∈ {
                        magnitude ∈ {|0..10|} -- apgar_total_value
                      }
                    }
                  }
                }
              }
            }
          }
          POINT_EVENT[at0026] occurrences ∈ {0..1} ∈ { -- 2 minutes
            offset ∈ {
              DV_DURATION[at9003] ∈ {
                value ∈ {PT2M}
              }
            }
            data ∈ {
              use_node ITEM_LIST[at0049] /data[at0002]/events[at0003]/data[at0001]
            }
          }
          POINT_EVENT[at0027] occurrences matches {0..1} matches {...}  -- 3 minutes
          POINT_EVENT[at0028] occurrences matches {0..1} matches {...}  -- 5 minutes
          POINT_EVENT[at0031] occurrences matches {0..1} matches {...}  -- 10 minuten
                }
            }
        }
    }
  
rules
  check apgar_total_value = apgar_heartrate_value + apgar_respiratory_value + 
        apgar_reflex_value + apgar_muscle_tone_value + apgar_skin_colour_value
    
symbols
  symbol_definitions = <
    ["en"] = <
       ["apgar_respiratory_value"] = <
           text = <"Apgar score respiratory value">
       >
       ["apgar_heartrate_value"] = <
           text = <"Apgar score heartrate value">
       >
       ["apgar_muscle_tone_value"] = <
           text = <"Apgar score muscle tone value">
       >
       ["apgar_reflex_value"] = <
           text = <"Apgar score reflex value">
       >
       ["apgar_skin_colour_value"] = <
           text = <"Apgar score skin_colour value">
       >
       ["apgar_total_value"] = <
           text = <"Apgar score total value">
       >
    >

    symbol_bindings = <
      ["apgar_respiratory_value"] =   <"/data[at0002]/events/data[at0001]/items[at0009]/value[at9001]/value">
      ["apgar_heartrate_value"] =     <"/data[at0002]/events/data[at0001]/items[at0005]/value/value">
      ["apgar_muscle_tone_value"] =   <"/data[at0002]/events/data[at0001]/items[at0013]/value/value">
      ["apgar_reflex_value"] =        <"/data[at0002]/events/data[at0001]/items[at0017]/value/value">
      ["apgar_skin_colour_value"] =   <"/data[at0002]/events/data[at0001]/items[at0021]/value/value">
      ["apgar_total_value"] =         <"/data[at0002]/events/data[at0001]/items[at0025]/value[at9002]/magnitude">
    >
  >
----

.id-coded ADL2 syntax
[source, adl]
----
archetype (adl_version=2.0.6; rm_release=1.0.3; generated; uid=f27fac48-3acb-4061-9619-c783fd8346ab)
  openEHR-EHR-OBSERVATION.apgar.v1.0.1

description
  lifecycle_state = <"unmanaged">
  original_author = <...>
  details = <...>

definition
  OBSERVATION[id1] ∈ {  -- Apgar score
    data ∈ {
      HISTORY[id3] ∈ {
        events ∈ {
          POINT_EVENT[id4] occurrences ∈ {0..1} ∈ { -- 2 minutes
            offset ∈ {
              DV_DURATION[id42] ∈ {
                value ∈ {PT1M}
              }
            }
            data ∈ {
              ITEM_LIST[id2] ∈ {
                items ∈ {
                  ELEMENT[id10] occurrences ∈ {0..1} ∈ {
                    value ∈ {
                      DV_ORDINAL[id43] ∈ {
                        [value, symbol] ∈ { -- apgar_respiratory_value
                          [{0}, {[at11]}],
                          [{1}, {[at12]}],
                          [{2}, {[at13]}]
                        }
                      }
                    }
                  }
                  ELEMENT[id6] occurrences ∈ {0..1} ∈ {...} -- apgar_heartrate_value
                  ELEMENT[id14] occurrences ∈ {0..1} ∈ {...} -- apgar_muscle_tone_value
                  ELEMENT[id18] occurrences ∈ {0..1} ∈ {...} -- apgar_reflex_value
                  ELEMENT[id22] occurrences ∈ {0..1} ∈ {...} -- apgar_skin_colour_value
                  ELEMENT[id26] occurrences ∈ {0..1} ∈ {
                    value ∈ {
                      DV_COUNT[id48] ∈ {
                        magnitude ∈ {|0..10|} -- apgar_total_value
                      }
                    }
                  }
                }
              }
            }
          }
          POINT_EVENT[id27] occurrences ∈ {0..1} ∈ { -- 2 minutes
            offset ∈ {
              DV_DURATION[id49] ∈ {
                value ∈ {PT2M}
              }
            }
            data ∈ {
              use_node ITEM_LIST[id50] /data[id3]/events[id4]/data[id2]
            }
          }
          POINT_EVENT[id28] occurrences matches {0..1} matches {...}  -- 3 minutes
          POINT_EVENT[id29] occurrences matches {0..1} matches {...}  -- 5 minutes
          POINT_EVENT[id32] occurrences matches {0..1} matches {...}  -- 10 minuten
                }
            }
        }
    }

rules
  check apgar_total_value = apgar_heartrate_value + apgar_respiratory_value +
        apgar_reflex_value + apgar_muscle_tone_value + apgar_skin_colour_value

symbols
  symbol_definitions = <
    ["en"] = <
       ["apgar_respiratory_value"] = <
           text = <"Apgar score respiratory value">
       >
       ["apgar_heartrate_value"] = <
           text = <"Apgar score heartrate value">
       >
       ["apgar_muscle_tone_value"] = <
           text = <"Apgar score muscle tone value">
       >
       ["apgar_reflex_value"] = <
           text = <"Apgar score reflex value">
       >
       ["apgar_skin_colour_value"] = <
           text = <"Apgar score skin_colour value">
       >
       ["apgar_total_value"] = <
           text = <"Apgar score total value">
       >
    >

    symbol_bindings = <
      ["apgar_respiratory_value"] =   <"/data[id3]/events/data[id2]/items[id10]/value[id43]/value">
      ["apgar_heartrate_value"] =     <"/data[id3]/events/data[id2]/items[id6]/value[id44]/value">
      ["apgar_muscle_tone_value"] =   <"/data[id3]/events/data[id2]/items[id14]/value[id45]/value">
      ["apgar_reflex_value"] =        <"/data[id3]/events/data[id2]/items[id18]/value[id46]/value">
      ["apgar_skin_colour_value"] =   <"/data[id3]/events/data[id2]/items[id22]/value[id47]/value">
      ["apgar_total_value"] =         <"/data[id3]/events/data[id2]/items[id26]/value[id48]/magnitude">
    >
  >
----

The statement above assumes that the data element specified by the `apgar_total_value` location is being set externally, i.e. the above _does not set_ the total value, it just checks that whatever value is there correlates properly to its inputs.

The following example specifies the relationship between systolic, diastolic and mean arterial pressure (MAP), and also between pulse pressure and the systolic and diastolic values.

[source, adl]
----
rules
    check map_bp_value = diastolic_bp_value + 0.33 * (systolic_bp_value - diastolic_bp_value)
    
    check pulse_pressure_bp_value = systolic_bp_value - diastolic_bp_value
----

As for the previous example, the variables are mapped to the relevant archetype paths in the `data_bindings` section. These statements can be visualised in tools, e.g. as follows in the {openehr_awb}[ADL Workbench^].

[.text-center]
.ADL assertion examples
image::{images_uri}/assertions_bp_map_pp.png[id=assertions_bp_map_pp.png, align="center", width="70%"]

==== Value-dependent Existence

A useful kind of statement is to assert that a particular part of an archetype exists if a related element is defined and has a certain value. For example, the need might be to require a sub-tree of details to do with tobacco use be filled out at runtime if the data element representing smoking status is `True`. To do this, the following construct can be used:

[source, adl]
----
rules
    check is_smoker = True implies defined (smoking_details)
----

This makes used of both the EL `check` statement and the `defined()` predicate (a type of expression).

=== Execution Semantics

The Apgar archetype above provides a good example of multiplicity and how path-binding works. The data generated from this archetype will have at least 2 distinct instances of the `POINT_EVENT` structures, i.e. instances of `POINT_EVENT[at0003]`, `POINT_EVENT[at0027]`, `POINT_EVENT[at0028]`, and `POINT_EVENT[at0031]` (`POINT_EVENT[id4]`, `POINT_EVENT[id28]`, `POINT_EVENT[id29]`, and `POINT_EVENT[id32]`). The paths specified in the `symbol_bindings` section are of the form `.../events/...`, i.e. they do not specify any particular `POINT_EVENT` structure in the archetype. Since all the paths identify nodes inside the structure of one `POINT_EVENT` structure, they are bound in turn at runtime to the set of paths found in each instance of `POINT_EVENT` in the data. If there are 3 such instances in the data, the assertion will be evaluated 3 times, each time using the data points from within the `POINT_EVENT` instance being evaluated.

It should be noted that although in this archetype each `POINT_EVENT` structure has singular `occurrences`, this need not be so, and it could easily be the case that `POINT_EVENT[at0003]` (`POINT_EVENT[id4]`) had `occurrences matches {*}`. The data then could contain two or more instances of the `POINT_EVENT[at0003]` (`POINT_EVENT[id4]`) structure. The rule would then have been executed _for each one of these_ instances, with the same runtime binding rule, i.e. all paths mapped in each iteration to nodes within the _same instance structure_. Indeed, had the paths been of the form `.../events[at0003]/...` (`.../events[id4]/...`), this could have occurred.

An alternative to the above mapping is to bind paths to symbols according to all possible permutations of each path across all the instances of the `POINT_EVENT` structure found in the data. This is clearly not the intention of the rule, and would generate nonsense results.

