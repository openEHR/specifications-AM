== Specialisation Concepts

=== Differential and Flat Forms

Specialised archetypes in their authored form are represented in 'differential' form. The syntax is the same as for non-specialised archetypes, with two additions: specialisation paths (see <<Specialisation Paths>>) and ordering indicators (see <<Ordering of Sibling Nodes>>). For a specialised archetype therefore, the lineage of archetypes back to the ultimate parent must be taken into account in order to obtain its complete semantics.

Differential form means that the only attributes or objects mentioned are those that redefine corresponding elements in the parent and those that introduce new elements. The differential approach to representation of specialised archetypes give rise to the need for a _flat form_ of a specialised archetype: the equivalent archetype defined by the sum of the (differential) child and its parent, as if the child archetype had been defined standalone. The flat form of archetypes is used for building templates, and subsequently at runtime. It is generated by 'compressing' the effects of inheritance of the parent to the specialised child into a single archetype, and applies recursively all the way up an archetype lineage to the ultimate parent, which must be a top-level (non-specialised) archetype. For a top-level archetype, the flat-form is the same as its differential form (i.e. in a top-level archetype, every node is considered to be an extension node).

=== Specialisation Levels

In order to talk about archetypes at different levels of specialisation, a standard way of identifying the levels of specialisation is used, as follows:

* level 0: top-level, non-specialised archetypes
* level 1: specialisations of level 0 archetypes
* level 2: specialisations of level 1 archetypes
* etc.

For nodes carrying a node identifier, the specialisation level is always equal to the number of '.' characters found in the identifier.

=== Specialisation Paths

Because ADL is a block-structured language, the redefinition of nodes deep in the parent structure normally requires descending into the structure. Since it is common to want to further constrain only nodes deep within a structure in specialised archetype, a more convenient way is provided in ADL to do this using a _specialisation path_, illustrated by the following example:

.at-coded ADL2 archetype
[source, cadl]
--------
    OBSERVATION[at0000.1] ∈ {                                   -- Thyroid function tests
        /data[at0001]/events[at0002]/data[at0003]/items ∈ {
                ELEMENT[at0078.2] occurrences ∈ {0..1} ∈ {    -- TSH
                    value ∈ {
                        DV_QUANTITY[at9000.7] ∈ { ... }
                    }
                }
                ELEMENT[at0078.7] occurrences ∈ {0..1} ∈ {...} -- Free T3
                ...
            }
        }
    }
--------

.id-coded ADL2 archetype
[source, cadl]
--------
    OBSERVATION[id1.1] ∈ {                                   -- Thyroid function tests
        /data[id2]/events[id3]/data[id4]/items ∈ {
                ELEMENT[id79.2] occurrences ∈ {0..1} ∈ {    -- TSH
                    value ∈ {
                        DV_QUANTITY[id0.7] ∈ { ... }
                    }
                }
                ELEMENT[id79.7] occurrences ∈ {0..1} ∈ {...} -- Free T3
                ...
            }
        }
    }
--------

In this fragment, a path is used rather than an attribute name. A path can be used in this manner only if no further constraints are required 'on the way' into the deep structure, with the exception of at-code (id-code) overrides (since these can be syntactically accommodated within the path).

The rules for specialisation paths are as follows.

* A specialisation path is constructed down to the first attribute having any child objects to be further constrained in the present archetype.
* All path segments must carry an at-code (id-code) predicate.
* The shortest useful path that can be used is `/` followed by an attribute name from the top level class being constrained by the archetype.

=== Path Congruence

Any node in an archetype can unambiguously be located by its archetype path. For example, the text value of the 'problem' node of the `openEHR-EHR-EVALUATION.problem.v1` archetype shown at the top of the example in <<Redefinition for Specialisation>> is:

.at-coded ADL2 archetype
[source, cadl]
--------
    /data[at0001]/items[at0002]/value
--------

.id-coded ADL2 archetype
[source, cadl]
--------
    /data[id2]/items[id3]/value
--------

Similarly the path to the redefined version of the same node in the `openEHR-EHR-EVALUATION.problem-diagnosis.v1` archetype at the bottom of the same figure is:

.at-coded ADL2 archetype
[source, cadl]
--------
    /data[at0001]/items[at0002.1]/value
--------

.id-coded ADL2 archetype
[source, cadl]
--------
    /data[id2]/items[id3.1]/value
--------

By inspection, it can be seen that this path is a variant of the corresponding path in the parent archetype, where a particular object node identifier has been specialised.

In general, the path of every redefined node in a specialised archetype will have a direct equivalent in the parent archetype, which can be determined by removing one level of specialisation from any node identifiers within the specialised path that are at the level of specialisation of the specialised archetype (i.e. node identifiers corresponding to higher specialisation levels are not changed). In this way, the nodes in a specialised archetype source can be connected to their counterparts in parent archetypes, for purposes of validation and flattening.

Conversely, any given path in an archetype that has children will have congruent paths in the children wherever nodes have been specialised.

=== Redefinition Concepts

A specialised archetype definition at any level consists of a set of changes with respect to its flat parent. The technically available changes are categorised as follows.

[cols="1,2,2", options="header"]
|===
|Logical Intention|Physical Redefinition|Criteria

3+^|*Attibute node constraints*

|MANDATE an existing node.
|Differential attribute node refines existence to 1.
|Differential node has same attribute name as a node at the same path location in the flat parent.

|EXCLUDE an existing node.
|Differential attribute node refines existence to 0.
|Differential node has same attribute name as a node at the same path location in the flat parent.

|REFINE an existing node.
|Differential attribute node refines cardinality of attribute at corresponding location in flat parent.
|Differential node has same attribute name as a node at the same path location in the flat parent.

|ADD a new node.
|Differential attribute node will be added to parent object node at corresponding location in flat parent.
|Differential node does not exist in the flat parent, only in the Reference Model.

3+^|*Object node constraints*

|REFINE an existing node.
|Differential object node and sub-elements will OVERRIDE corresponding node, and some / all of its sub-elements from the flat parent
|Differential node has a specialised node identifier, and corresponding node in flat parent has max occurrences = 1 or else differential node is sole replacement and has max occurrences = 1.

|SPECIALISE an existing node.
|Differential object node(s) and sub-elements will OVERRIDE a CLONE of the corresponding node, and some / all of its sub-elements from the flat parent
|Differential node has a specialised node identifier, and corresponding node in flat parent has max occurrences > 1.

|ADD a new node.
|Differential object node(s) and sub-elements will be ADDed to container or single-valued attribute. In the case of a container, ordering can be controlled with the before/after constraint.
|Differential node has a specialised node identifier, and corresponding node in flat parent has max occurrences > 1.

|EXCLUDE an existing node.
|Differential object node DELETEs existing node which has min occurrences = 0 (i.e. can't delete a mandatory node).
|Differential node has same node identifier as corresponding node in parent, and occurrences = 0..0.

|FILL a slot.
|External reference node will be added as slot filler next to corresponding slot from flat parent.
|Differential node is an external reference node, has specialised node identifier of a slot in the flat parent.

|CLOSE a slot.
|Archetype slot node causes corresponding slot from flat parent to be closed to further filling.
|Differential node is an archetype slot node, with same node identifier as a slot in the flat parent, and has the 'closed' flag set.

|===

In the ADL syntax, objects can be specified in two places: under single-value attributes and under multiply-valued (container) attributes.

Within an archetype, multiple object constraint nodes may appear under a single-valued attribute. Each such node defines an _alternative_ that may be used to constrain data at that attribute position. An example is the `OBSERVATION._protocol_` attribute from the openEHR reference model: if multiple objects appear under this attribute, only one can be used at runtime to constrain data. When a single object node is refined by one or more alternatives in a child archetype, any redefined occurrences of the child must conform in the expected way to that of the parent node, i.e. be a narrowed interval.

Within a container attribute, the meaning of multiple objects is that each child object defines constraints on one or more members of the container in the data. The `occurrences` constraint on each one determines how many objects in the data match a given object constraint under the attribute. Valid occurrences intervals for each specialised child in this case are determined _collectively_, that is to say, by considering the occurrences of all the specialised children of a given parent node. As a consequence, for any child node in such a set that specialises the occurrences of the parent node, the occurrences of each such node need only _intersect_ the occurrences interval of the parent node. This is because it may be assumed (indeed, necessary) for the data to contain instances matching _more than one_ of the set. To correctly determine the effective occurrences of any node in a specialised group, the cardinality of the owning attribute must also be taken into account. For this reason, a particular concrete consequence of collective occurrences is that any given child node occurrences may have an unbounded upper limit (i.e. `*`) even if the upper bound of the cardinality of the owning attribute is finite.

The rules for redefinition of occurrences on object nodes is formally defined in the {openehr_am_aom2}#VSONCO[VSONCO validity rule^] in the AOM2 specification.

Object constraints can be specialised under both types of attributes by redefinition, refinement and exclusion. Addition can also be used under either kind of attribute: in both cases, it corresponds to an alternative. The actual semantics are described in terms of object node identification, type redefinition, and structural constraints (existence, cardinality and occurrences), and are the same for objects under single- and multiply-valued attributes. The following sections describe the details.

